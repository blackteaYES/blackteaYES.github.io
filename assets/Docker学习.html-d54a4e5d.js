import{_ as n,V as d,W as r,X as e,Y as i,$ as s,a0 as l,C as c}from"./framework-a71e09ed.js";const o="/assets/img/Docker学习/查看是否挂载成功.png",t="/assets/img/Docker学习/容器内部数据卷位置.png",m="/assets/img/Docker学习/默认容器数据卷的位置.png",u="/assets/img/Docker学习/默认容器数据卷里面的目录.png",p="/assets/img/Docker学习/dockerfile小总结.png",v="/assets/img/Docker学习/自定义同个tomcat镜像.png",h="/assets/img/Docker学习/创建阿里云镜像仓库.png",g="/assets/img/Docker学习/进入创建好的仓库管理.png",k="/assets/img/Docker学习/镜像构建后推送到阿里云仓库.png",b="/assets/img/Docker学习/阿里云镜像搜索提交上去的镜像.png",f={},x=e("h1",{id:"docker学习",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#docker学习","aria-hidden":"true"},"#"),i(" docker学习")],-1),_=e("h2",{id:"感谢",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#感谢","aria-hidden":"true"},"#"),i(" 感谢")],-1),y=e("strong",null,"b站尚谷硅周阳讲师",-1),D={href:"https://www.bilibili.com/video/BV1Ls411n7mx?p=34",target:"_blank",rel:"noopener noreferrer"},q=l(`<h2 id="docker常用命令" tabindex="-1"><a class="header-anchor" href="#docker常用命令" aria-hidden="true">#</a> docker常用命令</h2><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code>docker version : 查看docker版本信息

docker info : 查看docker基本信息

docker --help :  查看docker指令帮助,类似linux的man指令
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="docker镜像命令" tabindex="-1"><a class="header-anchor" href="#docker镜像命令" aria-hidden="true">#</a> docker镜像命令</h2><h3 id="docker-images" tabindex="-1"><a class="header-anchor" href="#docker-images" aria-hidden="true">#</a> docker images</h3><p>  查看本地可以运行的镜像模板</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code>options: &lt;!-- docker images--&gt;

1. -a  : 查看本地所有镜像(含中间影像层)
2. -q :  只显示镜像id
3. --digests : 显示镜像的摘要信息
4. --no-trunc : 显示完整的镜像信息
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="docker-search-imagename" tabindex="-1"><a class="header-anchor" href="#docker-search-imagename" aria-hidden="true">#</a> docker search imageName</h3><p>   imageName(镜像名字),dockerhub上搜索镜像</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code>options: &lt;!--docker search--&gt;

1. --no-trunc : 显示完整的镜像信息
2. -s : 列出收藏数(stars)不小于指定值的镜像
3. --automated : 只列出automated build类型的镜像
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="docker-pull-imagename-tag" tabindex="-1"><a class="header-anchor" href="#docker-pull-imagename-tag" aria-hidden="true">#</a> docker pull imageName:tag</h3><p>  imageName(镜像名字),tag(版本) , dockerhub上拉取镜像,不写tag,默认拉取最新版本(latest)</p><h3 id="docker-rmi-imagename-tag-imageid" tabindex="-1"><a class="header-anchor" href="#docker-rmi-imagename-tag-imageid" aria-hidden="true">#</a> docker rmi imageName:tag/imageId</h3><p>  imageId(镜像id)，imageName(镜像名字),tag(版本) , 删除镜像时，可以选择id或名称</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code>options: &lt;!--docker rmi--&gt;

1. docker rmi -f 镜像id : 删除单个镜像
2. docker rmi -f 镜像id 镜像id : 删除多个镜像
3. docker rmi -f $(docker images -qa) : 删除所有镜像,-qa 获得所有镜像的id(具体去看docker images指令)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="docker容器指令" tabindex="-1"><a class="header-anchor" href="#docker容器指令" aria-hidden="true">#</a> docker容器指令</h2><h3 id="新建并启动容器" tabindex="-1"><a class="header-anchor" href="#新建并启动容器" aria-hidden="true">#</a> 新建并启动容器</h3><p>  docker run [options] image [command] [agr...]</p><p>  例子:</p><p>  docker run -it imagId : 新创立容器,启动并进入容器内部根目录</p><p>  docker run -d -p 8001:8080 --name myTomcat01 tomcat : 新创立、启动容器,并将容器命名为myTomcat01,将容器内部8080端口映射至虚拟机8001端口, docker exec -it myTomcat01 /bin/bash 进入容器根目录</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code>options : &lt;!--docker run [options]--&gt;

1. --name :  隔一个空格,给当前新创立的容器起名称,例如: -- name myNginx

2. -d : 后台运行容器,并返回容器id,同时启动守护式容器（备注:开启后台运行,必须有前台处理，否则会关闭容器）

3. -i : 以交互模式启动容器,通常与-t同时使用

4. -t : 为容器重新分配一个伪输入终端

5. -P : 随机端口映射

6. -p : 指定端口映射,有以下四种:

   1. ip:hostPort:containerPort

   2. ip::containerPort

   3. hostPort:containerPort

   4. containerPort

      举例子: - p 8001:8080 -&gt; (tomcat端口映射)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="退出容器内部" tabindex="-1"><a class="header-anchor" href="#退出容器内部" aria-hidden="true">#</a> 退出容器内部</h3><ol style="padding-left:3em;"><li>exit : 容器停止退出</li><li>ctrl + P + Q : 容器不停止退出</li></ol><h3 id="启动容器" tabindex="-1"><a class="header-anchor" href="#启动容器" aria-hidden="true">#</a> 启动容器</h3><p>  docker start containerName/containerId</p><h3 id="重启容器" tabindex="-1"><a class="header-anchor" href="#重启容器" aria-hidden="true">#</a> 重启容器</h3><p>  docker restart containerName/containerId</p><h3 id="停止容器" tabindex="-1"><a class="header-anchor" href="#停止容器" aria-hidden="true">#</a> 停止容器</h3><p>  docker stop/kill containerName/containerId</p><ol style="padding-left:3em;"><li>stop ： 慢慢停止容器(备注:启动时 -d ,守护式不会停止)</li><li>kill ： 强制停止容器</li></ol><h3 id="删除容器" tabindex="-1"><a class="header-anchor" href="#删除容器" aria-hidden="true">#</a> 删除容器</h3><p>  docker rm/rm -f containerName/containerId</p><ol><li>rm : 删除没有运行的容器</li><li>rm -f : 强制删除,即使在运行</li><li>删除全部容器 <ol><li>docker rm -f $(docker ps -a -q)</li><li>docker ps -a -q | xargs docker rm</li></ol></li></ol><h3 id="docker-ps" tabindex="-1"><a class="header-anchor" href="#docker-ps" aria-hidden="true">#</a> docker ps</h3><p>  查看有哪些容器已经启动</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code>options :  &lt;!--docker ps [options]--&gt;

1. -a : 列出当前所有正在运行的容器 +  历史上运行过的
2. -l : 显示最近创建的容器
3. -n : 显示最近n个创建的容器
4. -q : 静默模式,只显示容器编号
5. --no-trunc : 不截断输出,完整信息显示
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="查看容器日志" tabindex="-1"><a class="header-anchor" href="#查看容器日志" aria-hidden="true">#</a> 查看容器日志</h3><p>  docker logs -f -t --tail 容器id/容器name</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>options: 

1. -t : 是加入时间戳
2. -f : 跟随最新的日志打印
3. -- tail : 数字，显示最后多少条
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="查看容器内运行的进程" tabindex="-1"><a class="header-anchor" href="#查看容器内运行的进程" aria-hidden="true">#</a> 查看容器内运行的进程</h3><p>  docker top 容器id/容器name</p><h3 id="查看容器内部细节" tabindex="-1"><a class="header-anchor" href="#查看容器内部细节" aria-hidden="true">#</a> 查看容器内部细节</h3><p>  docker inspect 容器id/容器name</p><h3 id="进入正在运行的容器并以命令行交互" tabindex="-1"><a class="header-anchor" href="#进入正在运行的容器并以命令行交互" aria-hidden="true">#</a> 进入正在运行的容器并以命令行交互</h3><ol style="padding-left:3em;"><li>docker exec -it 容器id/容器name : 直接进入容器启动命令的终端,不会启动新的进程(备注:不加 /bin/bash 的话不会进入到容器内部,但是可以在在指令结尾加入 容器内部指令,会返回信息,例如: docker exec -it 容器id ls -l /tmp)</li><li>docker attach 容器id/容器name : 直接进入容器启动命令的终端,不会启动新的进程</li></ol><h3 id="从容器内拷贝文件到主机上" tabindex="-1"><a class="header-anchor" href="#从容器内拷贝文件到主机上" aria-hidden="true">#</a> 从容器内拷贝文件到主机上</h3><p>  docker cp 容器id/容器name:容器路径 目标主机路径(外部主机)</p><p>  例如: docker cp myTomcat01:/tmp/假设存在.txt /usr。</p><h3 id="镜像commit" tabindex="-1"><a class="header-anchor" href="#镜像commit" aria-hidden="true">#</a> 镜像commit</h3><p>  提交容器副本使其成为一个新的镜像,docker ps就可以查看到新生成的镜像</p><p>  docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器id 要创建的(image:tag)目标镜像名称:[标签名]</p><p>  例如:</p><p>    docker commit -m=&quot;tomcat test commit 1&quot; -a=&quot;yy&quot; myTomcat01 atyy/mytomcat:1.1</p><h2 id="容器数据卷" tabindex="-1"><a class="header-anchor" href="#容器数据卷" aria-hidden="true">#</a> 容器数据卷</h2><h3 id="指令方式添加-v-指令" tabindex="-1"><a class="header-anchor" href="#指令方式添加-v-指令" aria-hidden="true">#</a> 指令方式添加 : -v 指令</h3><p>  docker run -it/-d -v /宿主机绝对路径:/容器目录 镜像名/镜像id (备注:不存在路径会自动创建的)</p><p>  功能:</p><p>​   可以实现容器与宿主机之间数据共享</p><p>​   容器停止退出后,主机修改后数据还是同步的</p><p>​   可以设置容器目录是否可以读写(备注:宿主机单向修改文件),例如:</p><p>  docker run -it/-d -v /宿主机绝对路径:/容器目录:ro 镜像名/镜像id ,docker inspect 查看volumesRW - &gt; false</p><ol style="padding-left:5em;"><li>查看是否挂载成功,docker inspect</li></ol><figure><img src="`+o+`" alt="查看是否挂载成功" tabindex="0" loading="lazy"><figcaption>查看是否挂载成功</figcaption></figure><h3 id="dockerfile添加" tabindex="-1"><a class="header-anchor" href="#dockerfile添加" aria-hidden="true">#</a> DockerFile添加 :</h3><ol><li><p>创建dockerfile的文件夹,用于存放dockerfile文件</p></li><li><p>在dockrfile文件中使用<strong>VOLUME</strong>指令来给镜像添加一个或多个数据卷</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token instruction"><span class="token keyword">VOLUME</span> [<span class="token string">&quot;/dataVolumeContainer1&quot;</span>,<span class="token string">&quot;/dataVolumeContainer2&quot;</span>]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>file构建</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code>编写dockerfile文件:
以下功能类似: docker run -it -v 宿主机绝对路径:/dataVolumeContainer1 -v 宿主机绝对路径:/dataVolumeContainer2 centos /bin/bash

<span class="token instruction"><span class="token keyword">FROM</span> centos</span>
<span class="token comment"># 容器内部数据卷位置,只可以写容器内部 </span>
<span class="token instruction"><span class="token keyword">VOLUME</span> [<span class="token string">&quot;/dataVolumeContainer1&quot;</span>,<span class="token string">&quot;/dataVolumeContainer2&quot;</span>]  </span>
<span class="token instruction"><span class="token keyword">CMD</span> echo <span class="token string">&quot;test dockerfile success&quot;</span></span>
<span class="token instruction"><span class="token keyword">CMD</span> /bin/bash</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>build生成镜像</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code>docker build -f /docker/DockerFilePack/DockerFile -t yy/centos .
解析: 
	-f : dockerfile文件目录
	-t : 命名空间,构建的镜像名字
	 . : 镜像构建过程中的上下文环境的目录
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>run 创建生成容器</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code>docker run -it 容器id/容器name

备注:docker挂载主机目录docker访问出现cannot open directory .:Permission denied
解决办法: 在挂载目录后多加一个 --privileged=true 参数即可
例如: docker run -it -v /宿主机绝对路径:/容器路径 --privileged=true imagesName/imageId
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ 容器内部数据卷位置如下图:</p></li></ol><figure><img src="`+t+`" alt="容器内部数据卷位置" tabindex="0" loading="lazy"><figcaption>容器内部数据卷位置</figcaption></figure><ol start="6"><li><p>查看启动容器时不指定宿主机容器数据卷,docker默认指定的容器数据卷位置</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code>docker inspect 容器id/容器name
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可以看到所在的默认容器数据卷的位置:</p></li></ol><figure><img src="`+m+'" alt="默认容器数据卷的位置" tabindex="0" loading="lazy"><figcaption>默认容器数据卷的位置</figcaption></figure><p>   可以看到里面的目录:</p><figure><img src="'+u+`" alt="默认容器数据卷里面的目录" tabindex="0" loading="lazy"><figcaption>默认容器数据卷里面的目录</figcaption></figure><h3 id="容器间传递共享" tabindex="-1"><a class="header-anchor" href="#容器间传递共享" aria-hidden="true">#</a> 容器间传递共享</h3><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code>docker run -it --name 容器name/容器id --volumes-from 被继承(容器name/容器id) 镜像name/镜像id
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>  可以实现容器间数据卷的共享(增删查改会影响继承到的容器数据卷)，即使删除容器，只要不删除完所有相同继承的容器，那么容器卷数据就不会被删除，即使被继承容器删除，子容器还是有相同数据。</p><p><strong>结论: 容器之间配置信息的传递,数据卷的生命周期一直持续到没有容器使用它为止。</strong></p><h2 id="dockerfile-详解" tabindex="-1"><a class="header-anchor" href="#dockerfile-详解" aria-hidden="true">#</a> dockerfile 详解</h2><h3 id="保留字指令" tabindex="-1"><a class="header-anchor" href="#保留字指令" aria-hidden="true">#</a> 保留字指令</h3><ol><li><p>FROM : 基础镜像,当前新镜像是基于那个镜像的</p></li><li><p>MAINTAINER ：镜像维护者的姓名和邮箱地址</p></li><li><p>RUN ：容器构建时需要运行的命令</p></li><li><p>EXPOSE ：当前容器对外暴露出的端口</p></li><li><p>WORKDIR ：指定在创建容器后,终端默认登录进来的工作目录,一个落脚点</p></li><li><p>ENV : 用来构建镜像过程中设置的环境变量</p></li><li><p>ADD : 将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包</p></li><li><p>COPY ：类似ADD,拷贝文件和目录到镜像中。将从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路劲&gt;位置 ,如下:</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code>1. COPY src dest

2. COPY [&quot;src&quot;,&quot;dest&quot;]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>VOLUME : 容器数据卷,用于数据保存和持久化工作</p></li><li><p>CMD : 指定一个容器启动时要运行的指令;Dockerfile中可以有多个CMD指令,但只有最后一个生效,CMD会被docker run之后的参数替换。</p></li><li><p>ENTRYPOINT ：指定一个容器启动时要运行的命令;ENTRYPOINT的目的和CMD一样,都是在指定容器启动程序及参数</p></li><li><p>ONBUILD : 当构建一个被继承的Dockerfile时运行命令,父镜像在被子继承后父镜像的ONBUILD被触发</p></li></ol><p><strong>小总结如下图</strong>:</p><figure><img src="`+p+'" alt="dockerfile小总结" tabindex="0" loading="lazy"><figcaption>dockerfile小总结</figcaption></figure><h3 id="案例" tabindex="-1"><a class="header-anchor" href="#案例" aria-hidden="true">#</a> 案例</h3><p>  自定义同个tomcat镜像:</p><figure><img src="'+v+'" alt="自定义同个tomcat镜像" tabindex="0" loading="lazy"><figcaption>自定义同个tomcat镜像</figcaption></figure><h3 id="本地镜像提交到阿里云" tabindex="-1"><a class="header-anchor" href="#本地镜像提交到阿里云" aria-hidden="true">#</a> 本地镜像提交到阿里云</h3><ol><li>创建阿里云镜像仓库。</li></ol><figure><img src="'+h+'" alt="创建阿里云镜像仓库" tabindex="0" loading="lazy"><figcaption>创建阿里云镜像仓库</figcaption></figure><ol start="2"><li>进入创建好的仓库管理。</li></ol><figure><img src="'+g+'" alt="进入创建好的仓库管理" tabindex="0" loading="lazy"><figcaption>进入创建好的仓库管理</figcaption></figure><ol start="3"><li>根据第二步的提示，去登录阿里云Docker Registry,将镜像构建后推送到阿里云仓库。</li></ol><figure><img src="'+k+'" alt="镜像构建后推送到阿里云仓库" tabindex="0" loading="lazy"><figcaption>镜像构建后推送到阿里云仓库</figcaption></figure><ol start="4"><li>去阿里云镜像搜索提交上去的镜像(注:只有仓库是公开的其他人才可以搜索到)。</li></ol><figure><img src="'+b+'" alt="阿里云镜像搜索提交上去的镜像" tabindex="0" loading="lazy"><figcaption>阿里云镜像搜索提交上去的镜像</figcaption></figure>',91);function N(V,C){const a=c("ExternalLinkIcon");return d(),r("div",null,[x,_,e("p",null,[y,i(": "),e("a",D,[i("https://www.bilibili.com/video/BV1Ls411n7mx?p=34"),s(a)])]),q])}const P=n(f,[["render",N],["__file","Docker学习.html.vue"]]);export{P as default};
