import{_ as e,V as t,W as a,a0 as r}from"./framework-a71e09ed.js";const i={},l=r('<h1 id="设计模式简述" tabindex="-1"><a class="header-anchor" href="#设计模式简述" aria-hidden="true">#</a> 设计模式简述</h1><p>  设计模式本身没有法则，但是设计模式所遵循的原则和规范可以被称为法则。</p><p>  以下是常见的设计模式法则：</p><ol style="padding-left:5em;"><li> 单一职责原则（Single Responsibility Principle，SRP）：一个类应该只有一个引起它变化的原因。</li><li> 开闭原则（Open-Closed Principle，OCP）：软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。</li><li>里氏替换原则（Liskov Substitution Principle，LSP）：任何基类可以出现的地方，子类一定可以出现。</li><li>依赖倒置原则（Dependency Inversion Principle，DIP）：高层模块不应该依赖底层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。</li><li>合成复用原则（Composite Reuse Principle， CRP）：尽量使用对象组合，而不是继承来达到复用的目的。</li><li>接口隔离原则（Interface Segregation Principle，ISP）：客户端不应该依赖它不需要的接口。</li><li>迪米特法则（Law of Demeter，LoD）：一个对象应该对其他对象保持最少的了解。</li></ol><h2 id="以下是常用的设计模式" tabindex="-1"><a class="header-anchor" href="#以下是常用的设计模式" aria-hidden="true">#</a> 以下是常用的设计模式</h2><h3 id="创建型模式" tabindex="-1"><a class="header-anchor" href="#创建型模式" aria-hidden="true">#</a> 创建型模式</h3><p>  创建型模式主要关注对象的创建过程，包括如何创建对象、如何管理对象的生命周期、如何避免重复创建对象等。</p><ol style="padding-left:3em;"><li><a href="创造型模式.html#简单工厂模式-simple-factory-pattern">简单工厂模式（Simple Factory Pattern）</a></li><li><a href="创造型模式.html#工厂方法模式-factory-method-pattern">工厂方法模式（Factory Method Pattern）</a></li><li><a href="创造型模式.html#抽象工厂模式-abstract-factory-pattern">抽象工厂模式（Abstract Factory Pattern）</a></li><li><a href="创造型模式.html#单例模式-singleton-pattern">单例模式（Singleton Pattern）</a></li><li><a href="创造型模式.html#原型模式-prototype-pattern">原型模式（Prototype Pattern）</a></li><li><a href="创造型模式.html#建造者模式-builder-pattern">建造者模式（Builder Pattern）</a></li></ol><h3 id="结构型模式" tabindex="-1"><a class="header-anchor" href="#结构型模式" aria-hidden="true">#</a> 结构型模式</h3><p>  结构型模式主要关注对象的组织方式，包括如何将对象组合成更大的结构、如何简化对象之间的交互、如何动态地修改对象的结构等。</p><ol style="padding-left:3em;"><li><a href="结构型模式#适配器模式-adapter-pattern">适配器模式（Adapter Pattern）</a></li><li><a href="结构型模式#桥接模式-bridge-pattern">桥接模式（Bridge Pattern）</a></li><li><a href="结构型模式#装饰器模式-decorator-pattern">装饰器模式（Decorator Pattern）</a></li><li><a href="结构型模式#组合模式-composite-pattern">组合模式（Composite Pattern）</a></li><li><a href="结构型模式#外观模式-facade-pattern">外观模式（Facade Pattern）</a></li><li><a href="结构型模式#享元模式-flyweight-pattern">享元模式（Flyweight Pattern）</a></li><li><a href="结构型模式#代理模式-proxy-pattern">代理模式（Proxy Pattern）</a></li></ol><h3 id="行为型模式" tabindex="-1"><a class="header-anchor" href="#行为型模式" aria-hidden="true">#</a> 行为型模式</h3><p>  行为型模式主要关注对象之间的交互和协作方式，包括如何定义对象的行为、如何让对象之间的交互更加灵活和可扩展、如何处理对象之间的依赖关系等。</p><ol style="padding-left:3em;"><li><a href="行为型模式#责任链模式-chain-of-responsibility-pattern">责任链模式(Chain of Responsibility Pattern)</a></li><li><a href="行为型模式#命令模式-command-pattern">命令模式(Command Pattern)</a></li><li><a href="行为型模式#解释器模式-interpreter-pattern">解释器模式(Interpreter Pattern)</a></li><li><a href="行为型模式#迭代器模式-iterator-pattern">迭代器模式(Iterator Pattern)</a></li><li><a href="行为型模式#中介者模式-mediator-pattern">中介者模式(Mediator Pattern)</a></li><li><a href="行为型模式#备忘录模式-memento-pattern">备忘录模式(Memento Pattern)</a></li><li><a href="行为型模式#观察者模式-observer-pattern">观察者模式(Observer Pattern)</a></li><li><a href="行为型模式#状态模式-state-pattern">状态模式(State Pattern)</a></li><li><a href="行为型模式#策略模式-strategy-pattern">策略模式(Strategy Pattern)</a></li><li><a href="行为型模式#模板方法模式-template-method-pattern">模板方法模式(Template Method Pattern)</a></li><li><a href="行为型模式#访问者模式-visitor-pattern">访问者模式(Visitor Pattern)</a></li></ol>',14),n=[l];function o(h,p){return t(),a("div",null,n)}const s=e(i,[["render",o],["__file","设计模式的原则和规范.html.vue"]]);export{s as default};
